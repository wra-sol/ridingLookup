import { 
  Env, 
  QueryParams, 
  MapboxResponse, 
  NominatimResult, 
  GoogleGeocodeResponse,
  GoogleBatchGeocodeRequest,
  GoogleBatchGeocodeResponse,
  GeoGratisResponse,
  GeoGratisResult,
  GoogleAddressComponents
} from './types';
import { getTimeoutConfig, getRetryConfig, TIME_CONSTANTS, TIME_CONSTANTS_SECONDS, QUALITY_THRESHOLDS } from './config';
import { 
  safeValidateGeoGratis,
  safeValidateGoogleGeocode,
  safeValidateGoogleBatchGeocode,
  safeValidateNominatim,
  safeValidateMapbox
} from './validation';

// Geocoding cache entry interface
interface GeocodingCacheEntry {
  lon: number;
  lat: number;
  timestamp: number;
  provider: string;
  qualifier?: string; // GeoGratis qualifier (e.g., 'INTERPOLATED_POSITION')
  score?: number; // GeoGratis quality score (0-1)
}

// Reverse geocoding cache entry interface
interface ReverseGeocodingCacheEntry {
  formattedAddress: string;
  components: GoogleAddressComponents;
  timestamp: number;
}

// GeoGratis-first for geolocation; normalization via Google reverse geocode when key is set.
const BATCH_GEOCODING_CONFIG = {
  ENABLED: true,
  MAX_BATCH_SIZE: 10,
  PROVIDER: 'individual' as 'individual' | 'google' // 'individual' = GeoGratis-first; 'google' = batch Google (optional fallback)
};

// Use quality threshold from config
const GEOGRATIS_MIN_SCORE = QUALITY_THRESHOLDS.GEOGRATIS_MIN_SCORE;

/**
 * Generates a normalized cache key for geocoding requests.
 * Normalizes query parameters to ensure consistent caching.
 * 
 * @param query - Query parameters (address, postal, city, state, country)
 * @param provider - Geocoding provider name (e.g., 'geogratis', 'google', 'mapbox')
 * @returns Cache key string
 */
export function generateGeocodingCacheKey(query: QueryParams, provider: string): string {
  const normalizedQuery = {
    address: query.address?.toLowerCase().trim(),
    postal: query.postal?.toLowerCase().trim().replace(/\s+/g, ''),
    city: query.city?.toLowerCase().trim(),
    state: query.state?.toLowerCase().trim(),
    country: query.country?.toLowerCase().trim()
  };
  
  return `geocoding:${provider}:${JSON.stringify(normalizedQuery)}`;
}

/**
 * Retrieves a cached geocoding result from KV storage.
 * Validates cache entry age (24 hour TTL) and returns null if expired.
 * Does not delete expired entries - they will be cleaned up by KV TTL or when cache reaches limit.
 * 
 * @param env - Environment bindings containing GEOCODING_CACHE KV namespace
 * @param cacheKey - Cache key generated by generateGeocodingCacheKey
 * @returns Cached coordinates with quality info, or null if not found/expired
 */
export async function getCachedGeocoding(env: Env, cacheKey: string): Promise<{ lon: number; lat: number; qualifier?: string; score?: number } | null> {
  if (!env.GEOCODING_CACHE) return null;
  
  try {
    const cached = await env.GEOCODING_CACHE.get(cacheKey, 'json') as GeocodingCacheEntry | null;
    if (!cached) return null;
    
    // Check if cache entry is still valid (24 hours TTL)
    // Don't delete expired entries - let KV TTL handle cleanup
    const maxAge = TIME_CONSTANTS.TWENTY_FOUR_HOURS_MS;
    if (Date.now() - cached.timestamp > maxAge) {
      return null;
    }
    
    return { 
      lon: cached.lon, 
      lat: cached.lat,
      qualifier: cached.qualifier,
      score: cached.score
    };
  } catch (error) {
    console.warn('Failed to get cached geocoding result:', error);
    return null;
  }
}

/**
 * Stores a geocoding result in KV cache with 24-hour TTL.
 * Includes quality metadata (qualifier, score) for GeoGratis results.
 * 
 * @param env - Environment bindings containing GEOCODING_CACHE KV namespace
 * @param cacheKey - Cache key generated by generateGeocodingCacheKey
 * @param lon - Longitude
 * @param lat - Latitude
 * @param provider - Geocoding provider name
 * @param qualifier - Optional quality qualifier (e.g., 'INTERPOLATED_POSITION')
 * @param score - Optional quality score (0-1 scale)
 */
export async function setCachedGeocoding(env: Env, cacheKey: string, lon: number, lat: number, provider: string, qualifier?: string, score?: number): Promise<void> {
  if (!env.GEOCODING_CACHE) return;
  
  try {
    const entry: GeocodingCacheEntry = {
      lon,
      lat,
      timestamp: Date.now(),
      provider,
      qualifier,
      score
    };
    
    // Store with 24 hour TTL
    await env.GEOCODING_CACHE.put(cacheKey, JSON.stringify(entry), {
      expirationTtl: TIME_CONSTANTS_SECONDS.TWENTY_FOUR_HOURS
    });
  } catch (error) {
    console.warn('Failed to cache geocoding result:', error);
  }
}

/**
 * Generates a normalized cache key for reverse geocoding requests.
 * Normalizes coordinates to ~1m precision (5 decimal places) for consistent caching.
 * 
 * @param lat - Latitude
 * @param lon - Longitude
 * @returns Cache key string
 */
export function generateReverseGeocodingCacheKey(lat: number, lon: number): string {
  // Normalize coordinates to 5 decimal places (~1m precision)
  const normalizedLat = (Math.round(lat * 100000) / 100000).toString();
  const normalizedLon = (Math.round(lon * 100000) / 100000).toString();
  
  return `reverse:google:${normalizedLat},${normalizedLon}`;
}

/**
 * Retrieves a cached reverse geocoding result from KV storage.
 * Validates cache entry age (24 hour TTL) and returns null if expired.
 * Does not delete expired entries - they will be cleaned up by KV TTL or when cache reaches limit.
 * 
 * @param env - Environment bindings containing GEOCODING_CACHE KV namespace
 * @param cacheKey - Cache key generated by generateReverseGeocodingCacheKey
 * @returns Cached reverse geocoding result, or null if not found/expired
 */
export async function getCachedReverseGeocoding(env: Env, cacheKey: string): Promise<{ formattedAddress: string; components: GoogleAddressComponents } | null> {
  if (!env.GEOCODING_CACHE) return null;
  
  try {
    const cached = await env.GEOCODING_CACHE.get(cacheKey, 'json') as ReverseGeocodingCacheEntry | null;
    if (!cached) return null;
    
    // Check if cache entry is still valid (24 hours TTL)
    // Don't delete expired entries - let KV TTL handle cleanup
    const maxAge = TIME_CONSTANTS.TWENTY_FOUR_HOURS_MS;
    if (Date.now() - cached.timestamp > maxAge) {
      return null;
    }
    
    return {
      formattedAddress: cached.formattedAddress,
      components: cached.components
    };
  } catch (error) {
    console.warn('Failed to get cached reverse geocoding result:', error);
    return null;
  }
}

/**
 * Stores a reverse geocoding result in KV cache with 24-hour TTL.
 * 
 * @param env - Environment bindings containing GEOCODING_CACHE KV namespace
 * @param cacheKey - Cache key generated by generateReverseGeocodingCacheKey
 * @param result - Reverse geocoding result with formatted address and components
 */
export async function setCachedReverseGeocoding(env: Env, cacheKey: string, result: { formattedAddress: string; components: GoogleAddressComponents }): Promise<void> {
  if (!env.GEOCODING_CACHE) return;
  
  try {
    const entry: ReverseGeocodingCacheEntry = {
      formattedAddress: result.formattedAddress,
      components: result.components,
      timestamp: Date.now()
    };
    
    // Store with 24 hour TTL
    await env.GEOCODING_CACHE.put(cacheKey, JSON.stringify(entry), {
      expirationTtl: TIME_CONSTANTS_SECONDS.TWENTY_FOUR_HOURS
    });
  } catch (error) {
    console.warn('Failed to cache reverse geocoding result:', error);
  }
}

// Non-retriable error type
class NonRetriableError extends Error {
  nonRetriable: boolean;
  constructor(message: string) {
    super(message);
    this.nonRetriable = true;
  }
}

// Retry utility function with jitter and non-retriable support
async function withRetry<T>(
  fn: () => Promise<T>,
  config: ReturnType<typeof getRetryConfig>,
  operation: string
): Promise<T> {
  let lastError: Error;
  
  for (let attempt = 1; attempt <= config.maxAttempts; attempt++) {
    try {
      const result = await fn();
      if (attempt > 1) {
      }
      return result;
    } catch (error) {
      lastError = error as Error;
      
      // Do not retry non-retriable errors
      if ((lastError as any)?.nonRetriable) {
        console.error(`[GEOCODING] ${operation} failed with non-retriable error:`, lastError.message);
        throw lastError;
      }
      
      if (attempt === config.maxAttempts) {
        console.error(`[GEOCODING] ${operation} failed after ${config.maxAttempts} attempts:`, lastError.message);
        throw lastError;
      }
      
      const delay = Math.min(
        config.baseDelay * Math.pow(config.backoffMultiplier, attempt - 1),
        config.maxDelay
      );
      const jitteredDelay = delay + Math.random() * 1000;
      
      console.warn(`[GEOCODING] ${operation} attempt ${attempt} failed, retrying in ${Math.round(jitteredDelay)}ms:`, lastError.message);
      await new Promise(resolve => setTimeout(resolve, jitteredDelay));
    }
  }
  
  throw lastError!;
}

// Timeout utility function
async function withTimeout<T>(promise: Promise<T>, timeoutMs: number, operation: string): Promise<T> {
  const timeoutPromise = new Promise<never>((_, reject) => {
    setTimeout(() => reject(new Error(`${operation} timed out after ${timeoutMs}ms`)), timeoutMs);
  });
  
  return Promise.race([promise, timeoutPromise]);
}

export type GeocodeResult = { lon: number; lat: number; normalizedAddress?: string; addressComponents?: GoogleAddressComponents };

export type GeocodeBatchResult = { lon: number; lat: number; success: boolean; error?: string; normalizedAddress?: string; addressComponents?: GoogleAddressComponents };

/**
 * Parses Google address_components array into structured address components object.
 * Extracts all available address parts from Google's response.
 */
function parseGoogleAddressComponents(result: any): GoogleAddressComponents | undefined {
  if (!result || !result.address_components || !Array.isArray(result.address_components)) {
    return undefined;
  }

  const components: GoogleAddressComponents = {};
  
  // Helper to find component by type
  const getComponent = (types: string[]): string | undefined => {
    const component = result.address_components.find((comp: any) => 
      comp.types && Array.isArray(comp.types) && types.some(type => comp.types.includes(type))
    );
    return component?.long_name || component?.short_name;
  };

  // Extract all address components
  components.street_number = getComponent(['street_number']);
  components.route = getComponent(['route']);
  components.subpremise = getComponent(['subpremise']);
  components.locality = getComponent(['locality']);
  components.administrative_area_level_1 = getComponent(['administrative_area_level_1']);
  components.administrative_area_level_2 = getComponent(['administrative_area_level_2']);
  components.administrative_area_level_3 = getComponent(['administrative_area_level_3']);
  components.administrative_area_level_4 = getComponent(['administrative_area_level_4']);
  components.administrative_area_level_5 = getComponent(['administrative_area_level_5']);
  components.country = getComponent(['country']);
  components.postal_code = getComponent(['postal_code']);
  components.postal_code_suffix = getComponent(['postal_code_suffix']);
  components.neighborhood = getComponent(['neighborhood', 'sublocality']);
  components.sublocality = getComponent(['sublocality']);
  components.sublocality_level_1 = getComponent(['sublocality_level_1']);
  components.sublocality_level_2 = getComponent(['sublocality_level_2']);
  components.sublocality_level_3 = getComponent(['sublocality_level_3']);
  components.sublocality_level_4 = getComponent(['sublocality_level_4']);
  components.sublocality_level_5 = getComponent(['sublocality_level_5']);
  components.premise = getComponent(['premise']);
  components.establishment = getComponent(['establishment']);
  components.point_of_interest = getComponent(['point_of_interest']);
  components.park = getComponent(['park']);
  components.street_address = getComponent(['street_address']);
  components.intersection = getComponent(['intersection']);
  components.political = getComponent(['political']);
  components.colloquial_area = getComponent(['colloquial_area']);
  components.ward = getComponent(['ward']);

  // Add formatted address and other metadata
  if (result.formatted_address) {
    components.formatted_address = result.formatted_address;
  }
  if (result.place_id) {
    components.place_id = result.place_id;
  }
  if (result.types && Array.isArray(result.types)) {
    components.types = result.types;
  }
  if (result.plus_code) {
    components.plus_code = result.plus_code;
  }
  if (result.geometry?.viewport) {
    components.viewport = {
      northeast: result.geometry.viewport.northeast,
      southwest: result.geometry.viewport.southwest
    };
  }
  if (result.geometry?.bounds) {
    components.bounds = {
      northeast: result.geometry.bounds.northeast,
      southwest: result.geometry.bounds.southwest
    };
  }

  // Only return if we have at least some components
  const hasAnyComponent = Object.keys(components).some(key => 
    key !== 'formatted_address' && key !== 'place_id' && key !== 'types' && 
    key !== 'plus_code' && key !== 'viewport' && key !== 'bounds' && 
    components[key as keyof GoogleAddressComponents] !== undefined
  );

  return hasAnyComponent || components.formatted_address ? components : undefined;
}

/**
 * Reverse-geocodes (lat, lon) via Google Geocoding API to obtain a normalized formatted address and components.
 * Uses X-Google-API-Key header or GOOGLE_MAPS_KEY env. Returns null if no key, ZERO_RESULTS, or error.
 * Checks cache before making API call and stores results after successful calls.
 */
export async function normalizeAddressWithGoogle(
  env: Env,
  lat: number,
  lon: number,
  request?: Request,
  circuitBreaker?: { execute: (key: string, fn: () => Promise<any>) => Promise<any> }
): Promise<{ formattedAddress: string; components: GoogleAddressComponents } | null> {
  const headerKey = request?.headers.get('X-Google-API-Key');
  const key = headerKey || env.GOOGLE_MAPS_KEY;
  if (!key) return null;

  // Check cache first
  const cacheKey = generateReverseGeocodingCacheKey(lat, lon);
  const cached = await getCachedReverseGeocoding(env, cacheKey);
  if (cached) {
    return cached;
  }

  const doReverse = async (): Promise<{ formattedAddress: string; components: GoogleAddressComponents } | null> => {
    const params = new URLSearchParams({
      latlng: `${lat},${lon}`,
      key,
      region: 'ca'
    });
    const url = `https://maps.googleapis.com/maps/api/geocode/json?${params.toString()}`;
    const resp = await fetch(url, { headers: { 'User-Agent': 'riding-lookup/1.0' } });
    if (!resp.ok) return null;
    const rawData = await resp.json();
    const validation = safeValidateGoogleGeocode(rawData);
    if (!validation.success) return null;
    const data = validation.data;
    if (data.status !== 'OK' || !data.results?.length) return null;
    
    const result = data.results[0];
    const formattedAddress = result.formatted_address;
    if (typeof formattedAddress !== 'string' || formattedAddress.length === 0) {
      return null;
    }

    const components = parseGoogleAddressComponents(result);
    if (!components) {
      // Still return formatted address even if components parsing fails
      return {
        formattedAddress,
        components: { formatted_address: formattedAddress }
      };
    }

    return { formattedAddress, components };
  };

  try {
    const timeoutConfig = getTimeoutConfig(env);
    const timeoutMs = Math.min(timeoutConfig.geocoding, 5000);
    const fn = () => withTimeout(doReverse(), timeoutMs, 'Google reverse geocode');
    const out = circuitBreaker
      ? await circuitBreaker.execute('geocoding:google-reverse', fn)
      : await fn();
    
    // Cache the result if successful
    if (out) {
      await setCachedReverseGeocoding(env, cacheKey, out);
    }
    
    return out;
  } catch {
    return null;
  }
}

/**
 * Geocodes an address using the GeoGratis Geolocation API (Government of Canada).
 * This is the primary geocoding service used by the application.
 * 
 * @param qp - Query parameters containing address, postal code, city, state, or country
 * @returns Promise resolving to geocoding result with lon, lat, qualifier, and score, or null if failed
 * 
 * @remarks
 * - Uses the GeoGratis API endpoint: https://geogratis.gc.ca/services/geolocation/en/locate
 * - Requests score and component data via expand parameter for quality assessment
 * - Returns null on API errors, empty results, or invalid coordinates
 */
async function geocodeWithGeoGratis(qp: QueryParams): Promise<{ lon: number; lat: number; qualifier?: string; score?: number } | null> {
  try {
    // Build query string from available parameters
    const queryParts: string[] = [];
    if (qp.address) queryParts.push(qp.address);
    if (qp.postal) queryParts.push(qp.postal);
    if (qp.city) queryParts.push(qp.city);
    if (qp.state) queryParts.push(qp.state);
    if (qp.country) queryParts.push(qp.country);
    
    // Fallback to any available query if no structured parts
    if (queryParts.length === 0) {
      const query = qp.address || qp.postal || qp.city || qp.state || qp.country;
      if (!query) return null;
      queryParts.push(query);
    }
    
    const queryString = queryParts.join(', ');
    const params = new URLSearchParams({ 
      q: queryString,
      expand: 'score,component' // Request score and component for quality assessment
    });
    
    const url = `https://geogratis.gc.ca/services/geolocation/en/locate?${params.toString()}`;
    const resp = await fetch(url, { 
      headers: { "User-Agent": "riding-lookup/1.0" } 
    });
    
    if (!resp.ok) {
      console.warn(`[GEOCODING] GeoGratis API error: ${resp.status}`);
      return null;
    }
    
    const rawData = await resp.json();
    
    // Validate response structure with zod
    const validation = safeValidateGeoGratis(rawData);
    if (!validation.success) {
      console.warn(`[GEOCODING] GeoGratis response validation failed:`, validation.error.errors);
      return null;
    }
    
    const data = validation.data;
    
    // Check if we have results
    if (data.length === 0) {
      console.warn(`[GEOCODING] GeoGratis returned no results`);
      return null;
    }
    
    // Get the first result (best match)
    const firstResult = data[0];
    
    // Extract coordinates from geometry
    if (!firstResult.geometry || !firstResult.geometry.coordinates || firstResult.geometry.coordinates.length < 2) {
      console.warn(`[GEOCODING] GeoGratis result missing valid coordinates`);
      return null;
    }
    
    // GeoJSON coordinates are [lon, lat] format
    const lon = firstResult.geometry.coordinates[0];
    const lat = firstResult.geometry.coordinates[1];
    
    if (typeof lon !== 'number' || typeof lat !== 'number' || isNaN(lon) || isNaN(lat)) {
      console.warn(`[GEOCODING] GeoGratis result has invalid coordinates`);
      return null;
    }
    
    return {
      lon,
      lat,
      qualifier: firstResult.qualifier,
      score: firstResult.score
    };
  } catch (error) {
    console.warn(`[GEOCODING] GeoGratis geocoding failed:`, error instanceof Error ? error.message : 'Unknown error');
    return null;
  }
}

// Main geocoding function
/**
 * Geocodes a query (address/postal code) to coordinates if needed.
 * Uses cached results when available, with quality-aware caching for GeoGratis.
 * Falls back through multiple providers: GeoGratis -> Google -> Mapbox -> Nominatim.
 * When Google is used for forward geocoding, returns normalizedAddress (formatted_address).
 * 
 * @param env - Environment bindings (API keys, KV cache)
 * @param query - Query parameters (address, postal, city, state, country)
 * @param request - Optional request object for extracting Google API key from headers
 * @returns Promise resolving to {lon, lat, normalizedAddress?} coordinates
 * @throws Error if geocoding fails for all providers
 */
export async function geocodeIfNeeded(
  env: Env, 
  qp: QueryParams, 
  request?: Request,
  metrics?: {
    incrementMetric: (key: keyof import('./types').Metrics, value?: number) => void;
    recordTiming: (key: keyof import('./types').Metrics, duration: number) => void;
  },
  circuitBreaker?: {
    execute: (key: string, fn: () => Promise<any>) => Promise<any>;
  }
): Promise<GeocodeResult> {
  if (typeof qp.lat === "number" && typeof qp.lon === "number") {
    return { lon: qp.lon, lat: qp.lat };
  }
  const query = qp.address || qp.postal || qp.city || qp.state || qp.country;
  if (!query) throw new Error("Missing location: provide lat/lon or address/postal");

  const timeoutConfig = getTimeoutConfig(env);
  const timeoutMs = timeoutConfig.geocoding;
  
  const geocodePromise = (async () => {
    const startTime = Date.now();
    metrics?.incrementMetric('geocodingRequests');
    
    // ALWAYS try GeoGratis first
    const geogratisCacheKey = generateGeocodingCacheKey(qp, 'geogratis');
    const geogratisCached = await getCachedGeocoding(env, geogratisCacheKey);
    
    if (geogratisCached) {
      // Check cached result quality - reject if it was interpolated or had poor score
      const isInterpolated = geogratisCached.qualifier === 'INTERPOLATED_POSITION';
      const hasPoorScore = geogratisCached.score !== undefined && geogratisCached.score < GEOGRATIS_MIN_SCORE;
      
      if (!isInterpolated && !hasPoorScore) {
        // Cached result is good quality
        metrics?.incrementMetric('geocodingCacheHits');
        metrics?.recordTiming('totalGeocodingTime', Date.now() - startTime);
        return { lon: geogratisCached.lon, lat: geogratisCached.lat } as GeocodeResult;
      } else {
        // Cached result was poor quality, try fresh lookup
        console.warn(`[GEOCODING] Cached GeoGratis result was ${isInterpolated ? 'interpolated' : 'poor quality'}, fetching fresh result`);
      }
    }
    
    // Try GeoGratis API
    try {
      const geogratisResult = await geocodeWithGeoGratis(qp);
      
      if (geogratisResult) {
        // Check if result is acceptable
        const isInterpolated = geogratisResult.qualifier === 'INTERPOLATED_POSITION';
        const hasPoorScore = geogratisResult.score !== undefined && geogratisResult.score < GEOGRATIS_MIN_SCORE;
        
        if (isInterpolated) {
          console.warn(`[GEOCODING] GeoGratis returned INTERPOLATED_POSITION, falling back to ${env.GEOCODER || 'nominatim'}`);
        } else if (hasPoorScore) {
          console.warn(`[GEOCODING] GeoGratis returned poor score (${geogratisResult.score}), falling back to ${env.GEOCODER || 'nominatim'}`);
        } else {
          // GeoGratis result is good, use it and cache with quality info
          await setCachedGeocoding(env, geogratisCacheKey, geogratisResult.lon, geogratisResult.lat, 'geogratis', geogratisResult.qualifier, geogratisResult.score);
          metrics?.incrementMetric('geocodingSuccesses');
          metrics?.recordTiming('totalGeocodingTime', Date.now() - startTime);
          return { lon: geogratisResult.lon, lat: geogratisResult.lat } as GeocodeResult;
        }
      } else {
        // GeoGratis failed
        console.warn(`[GEOCODING] GeoGratis failed, falling back to ${env.GEOCODER || 'nominatim'}`);
      }
    } catch (error) {
      // GeoGratis threw an error
      console.warn(`[GEOCODING] GeoGratis error, falling back to ${env.GEOCODER || 'nominatim'}:`, error instanceof Error ? error.message : 'Unknown error');
    }
    
    // Fallback to existing provider logic
    const provider = (env.GEOCODER || "nominatim").toLowerCase();
    
    // Check cache for fallback provider
    const cacheKey = generateGeocodingCacheKey(qp, provider);
    const cached = await getCachedGeocoding(env, cacheKey);
    if (cached) {
      metrics?.incrementMetric('geocodingCacheHits');
      metrics?.recordTiming('totalGeocodingTime', Date.now() - startTime);
      return { lon: cached.lon, lat: cached.lat } as GeocodeResult;
    }
    
    metrics?.incrementMetric('geocodingCacheMisses');
    
    // Use circuit breaker and retry for geocoding
    let result: GeocodeResult;
    try {
      const geocodeFn = async (): Promise<GeocodeResult> => {
        let geocodeResult: GeocodeResult;
    
        if (provider === "google") {
          // Check for Google API key in header first, then fall back to environment variable
          const headerKey = request?.headers.get("X-Google-API-Key");
          const key = headerKey || env.GOOGLE_MAPS_KEY;
          if (!key) throw new Error("Google API key not provided. Set X-Google-API-Key header or configure GOOGLE_MAPS_KEY environment variable");
          const params = new URLSearchParams({ key });
          // Prefer structured components when available
          const componentFilters: string[] = [];
          if (qp.postal) componentFilters.push(`postal_code:${qp.postal.replace(/\s+/g, '')}`);
          if (qp.city) componentFilters.push(`locality:${qp.city}`);
          if (qp.state) componentFilters.push(`administrative_area:${qp.state}`);
          // Default to Canada unless caller specifies
          const country = (qp.country || 'CA').toUpperCase();
          componentFilters.push(`country:${country}`);
          if (componentFilters.length) params.set("components", componentFilters.join("|"));
          if (qp.address) params.set("address", qp.address);
          // Region bias for Canada
          params.set('region', 'ca');

          const url = `https://maps.googleapis.com/maps/api/geocode/json?${params.toString()}`;
          const resp = await fetch(url, { headers: { "User-Agent": "riding-lookup/1.0" } });
          if (!resp.ok) throw new Error(`Google error: ${resp.status}`);
          const rawData = await resp.json();
          // Validate response structure with zod
          const validation = safeValidateGoogleGeocode(rawData);
          if (!validation.success) {
            console.warn(`[GEOCODING] Google response validation failed:`, validation.error.errors);
            throw new Error(`Google API response validation failed`);
          }
          const data = validation.data;
          // Handle zero results or API errors without pointless retries; try Nominatim fallback immediately
          if (data.status === 'ZERO_RESULTS' || data.status === 'REQUEST_DENIED' || data.status === 'INVALID_REQUEST' || !data.results?.length) {
            console.error(`[GEOCODING] Google API failed (${data.status || 'no results'}), falling back to Nominatim`);
            // Fallback to Nominatim (same shaping as below)
            const nominatimParams = new URLSearchParams({ format: "jsonv2", limit: "1", country: "canada" });
            if (qp.address) nominatimParams.set("street", qp.address);
            if (qp.city) nominatimParams.set("city", qp.city);
            if (qp.state) nominatimParams.set("state", qp.state);
            if (qp.country) nominatimParams.set("country", qp.country);
            if (qp.postal) nominatimParams.set("postalcode", qp.postal);
            if (![qp.address, qp.city, qp.state, qp.country, qp.postal].some(Boolean)) {
              nominatimParams.set("q", query);
            }
            const nominatimUrl = `https://nominatim.openstreetmap.org/search?${nominatimParams.toString()}`;
            const nomResp = await fetch(nominatimUrl, { headers: { "User-Agent": "riding-lookup/1.0" } });
            if (nomResp.ok) {
            const rawResults = await nomResp.json();
            // Validate Nominatim response
            const nomValidation = safeValidateNominatim(rawResults);
            if (!nomValidation.success) {
              console.warn(`[GEOCODING] Nominatim response validation failed:`, nomValidation.error.errors);
              throw new Error(`Nominatim API response validation failed`);
            }
            const results = nomValidation.data;
            const first = results?.[0];
              if (first) {
                geocodeResult = { lon: Number(first.lon), lat: Number(first.lat) };
                return geocodeResult;
              }
            }
            console.error(`[GEOCODING] Nominatim fallback also failed, no results found`);
            throw new NonRetriableError("No results from Google");
          }
          
          // Handle other Google API error statuses
          if (data.status === 'OVER_QUERY_LIMIT' || data.status === 'UNKNOWN_ERROR') {
            throw new Error(`Google API error: ${data.status}`);
          }
          
          const result = data.results[0];
          const loc = result.geometry.location;
          const fmt = result.formatted_address;
          const components = parseGoogleAddressComponents(result);
          
          geocodeResult = {
            lon: loc.lng,
            lat: loc.lat,
            ...(typeof fmt === 'string' && fmt.length > 0 && { normalizedAddress: fmt }),
            ...(components && { addressComponents: components })
          };
        } else if (provider === "mapbox") {
          const token = env.MAPBOX_TOKEN;
          if (!token) throw new Error("MAPBOX_TOKEN not configured");
          const resp = await fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?limit=1&proximity=ca&access_token=${token}`, {
            headers: { "User-Agent": "riding-lookup/1.0" }
          });
          if (!resp.ok) throw new Error(`Mapbox error: ${resp.status}`);
          const data = await resp.json() as MapboxResponse;
          const feat = data?.features?.[0];
          if (!feat?.center) throw new Error("No results from Mapbox");
          geocodeResult = { lon: feat.center[0], lat: feat.center[1] };
        } else {
          // Nominatim
          // Default to Nominatim (OpenStreetMap)
          const nominatimParams = new URLSearchParams({ format: "jsonv2", limit: "1", country: "canada" });
          if (qp.address) nominatimParams.set("street", qp.address);
          if (qp.city) nominatimParams.set("city", qp.city);
          if (qp.state) nominatimParams.set("state", qp.state);
          if (qp.country) nominatimParams.set("country", qp.country);
          if (qp.postal) nominatimParams.set("postalcode", qp.postal);
          // Fallback free-form
          if (![qp.address, qp.city, qp.state, qp.country, qp.postal].some(Boolean)) {
            nominatimParams.set("q", query);
          }
          const nominatimUrl = `https://nominatim.openstreetmap.org/search?${nominatimParams.toString()}`;
          const resp = await fetch(nominatimUrl, { headers: { "User-Agent": "riding-lookup/1.0" } });
          if (!resp.ok) throw new Error(`Nominatim error: ${resp.status}`);
          const rawResults = await resp.json();
          // Validate Nominatim response
          const nomValidation = safeValidateNominatim(rawResults);
          if (!nomValidation.success) {
            console.warn(`[GEOCODING] Nominatim response validation failed:`, nomValidation.error.errors);
            throw new Error(`Nominatim API response validation failed`);
          }
          const results = nomValidation.data;
          const first = results?.[0];
          if (!first) throw new Error("No results from Nominatim");
          geocodeResult = { lon: Number(first.lon), lat: Number(first.lat) };
        }
        return geocodeResult;
      };

      const retryConfig = getRetryConfig();
      if (circuitBreaker) {
        result = await circuitBreaker.execute(`geocoding:${provider}`, async () => {
          return await withRetry(geocodeFn, retryConfig, `Geocoding ${provider}`);
        });
      } else {
        result = await withRetry(geocodeFn, retryConfig, `Geocoding ${provider}`);
      }
      
      metrics?.incrementMetric('geocodingSuccesses');
    } catch (error) {
      console.error(`[GEOCODING] Geocoding failed after ${Date.now() - startTime}ms:`, error instanceof Error ? error.message : 'Unknown error');
      metrics?.incrementMetric('geocodingFailures');
      if (error instanceof Error && error.message.includes('Circuit breaker is OPEN')) {
        console.error(`[GEOCODING] Circuit breaker is OPEN for provider: ${provider}`);
        metrics?.incrementMetric('geocodingCircuitBreakerTrips');
      }
      throw error;
    }
    
    // Cache the result
    await setCachedGeocoding(env, cacheKey, result.lon, result.lat, provider);
    
    metrics?.recordTiming('totalGeocodingTime', Date.now() - startTime);
    return result;
  })();

  return withTimeout(geocodePromise, timeoutMs, "Geocoding");
}

// Batch geocoding with Google
export async function geocodeBatchWithGoogle(
  env: Env, 
  queries: QueryParams[], 
  apiKey: string
): Promise<GeocodeBatchResult[]> {
  const results: GeocodeBatchResult[] = [];
  const errors: string[] = [];
  
  // Convert queries to Google batch format
  const addresses = queries.map(query => {
    const addressParts: string[] = [];
    
    if (query.address) addressParts.push(query.address);
    if (query.postal) addressParts.push(query.postal);
    if (query.city) addressParts.push(query.city);
    if (query.state) addressParts.push(query.state);
    if (query.country) addressParts.push(query.country);
    
    return {
      address: addressParts.join(', ')
    };
  });

  const batchRequest: GoogleBatchGeocodeRequest = {
    addresses
  };

  try {
    const response = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?key=${apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'riding-lookup/1.0'
      },
      body: JSON.stringify(batchRequest)
    });

    if (!response.ok) {
      const errorMsg = `Google batch geocoding HTTP error: ${response.status}`;
      errors.push(errorMsg);
      // Return failures for all queries
      for (let i = 0; i < queries.length; i++) {
        results.push({ lon: 0, lat: 0, success: false, error: errorMsg });
      }
      return results;
    }
    
    const rawData = await response.json();
    // Validate batch response structure
    const validation = safeValidateGoogleBatchGeocode(rawData);
    if (!validation.success) {
      const errorMsg = `Google batch geocoding validation failed: ${validation.error.errors.map(e => e.message).join(', ')}`;
      console.warn(`[GEOCODING] ${errorMsg}`);
      errors.push(errorMsg);
      // Return failures for all queries
      for (let i = 0; i < queries.length; i++) {
        results.push({ lon: 0, lat: 0, success: false, error: errorMsg });
      }
      return results;
    }
    
    const data = validation.data;
    
    if (data.results && data.results.length === queries.length) {
      // Process batch results
      let successCount = 0;
      let failureCount = 0;
      
      for (let i = 0; i < data.results.length; i++) {
        const result = data.results[i];
        const query = queries[i];
        
        if (result.geometry?.location) {
          // Parse address components if available in batch response
          // Note: Google batch API may have different structure, so we try to extract what we can
          const addressComponents = result.address_components 
            ? parseGoogleAddressComponents({ 
                address_components: result.address_components, 
                formatted_address: result.geocoded_address, 
                place_id: result.place_id, 
                types: result.types,
                geometry: result.geometry
              })
            : undefined;
          
          results.push({
            lon: result.geometry.location.lng,
            lat: result.geometry.location.lat,
            success: true,
            ...(result.geocoded_address && { normalizedAddress: result.geocoded_address }),
            ...(addressComponents && { addressComponents })
          });
          successCount++;
        } else {
          const errorMsg = `No results for query: ${query.address || query.postal || query.city || 'unknown'}`;
          results.push({
            lon: 0,
            lat: 0,
            success: false,
            error: errorMsg
          });
          errors.push(`Query ${i}: ${errorMsg}`);
          failureCount++;
        }
      }
      
      if (failureCount > 0) {
        console.warn(`Batch geocoding: ${successCount} succeeded, ${failureCount} failed out of ${queries.length} total`);
      }
    } else {
      // Batch response doesn't match query count - fallback to individual
      const errorMsg = `Batch response mismatch: expected ${queries.length} results, got ${data.results?.length || 0}`;
      errors.push(errorMsg);
      console.warn(errorMsg + ', falling back to individual geocoding');
      
      // Fallback to individual geocoding
      for (let i = 0; i < queries.length; i++) {
        const query = queries[i];
        try {
          const result = await geocodeIfNeeded(env, query);
          results.push({ ...result, success: true });
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : 'Geocoding failed';
          results.push({
            lon: 0,
            lat: 0,
            success: false,
            error: errorMsg
          });
          errors.push(`Query ${i}: ${errorMsg}`);
        }
      }
    }
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : 'Unknown error';
    console.error('Google batch geocoding failed:', errorMsg);
    errors.push(`Batch API error: ${errorMsg}`);
    
    // Fallback to individual geocoding
    for (let i = 0; i < queries.length; i++) {
      const query = queries[i];
      try {
        const result = await geocodeIfNeeded(env, query);
        results.push({ ...result, success: true });
      } catch (individualError) {
        const errorMsg = individualError instanceof Error ? individualError.message : 'Geocoding failed';
        results.push({
          lon: 0,
          lat: 0,
          success: false,
          error: errorMsg
        });
        errors.push(`Query ${i}: ${errorMsg}`);
      }
    }
  }

  // Log aggregated errors if any
  if (errors.length > 0) {
    console.warn(`Batch geocoding errors (${errors.length}):`, errors.slice(0, 5)); // Log first 5 errors
  }

  return results;
}

// Batch geocoding function
/**
 * Geocodes multiple addresses, using batch API when available or falling back to individual requests.
 * Automatically selects the best geocoding strategy based on configuration.
 * 
 * @param env - Environment bindings (API keys, KV cache)
 * @param queries - Array of query parameter objects to geocode
 * @param request - Optional request object for extracting Google API key
 * @returns Promise resolving to array of geocoding results with error information
 */
export async function geocodeBatch(
  env: Env, 
  queries: QueryParams[], 
  request?: Request,
  metrics?: {
    incrementMetric: (key: keyof import('./types').Metrics, value?: number) => void;
    recordTiming: (key: keyof import('./types').Metrics, duration: number) => void;
  },
  circuitBreaker?: {
    execute: (key: string, fn: () => Promise<any>) => Promise<any>;
  }
): Promise<GeocodeBatchResult[]> {
  if (!BATCH_GEOCODING_CONFIG.ENABLED || queries.length === 0) {
    return [];
  }

  const results: GeocodeBatchResult[] = [];
  
  // Process in batches
  const batchSize = BATCH_GEOCODING_CONFIG.MAX_BATCH_SIZE;
  for (let i = 0; i < queries.length; i += batchSize) {
    const batch = queries.slice(i, i + batchSize);
    
    try {
      if (BATCH_GEOCODING_CONFIG.PROVIDER === 'google' && env.GOOGLE_MAPS_KEY) {
        const batchResults = await geocodeBatchWithGoogle(env, batch, env.GOOGLE_MAPS_KEY);
        results.push(...batchResults);
      } else {
        // GeoGratis-first individual geocoding
        for (const query of batch) {
          try {
            const result = await geocodeIfNeeded(env, query, request, metrics, circuitBreaker);
            results.push({ lon: result.lon, lat: result.lat, success: true, normalizedAddress: result.normalizedAddress });
          } catch (error) {
            results.push({
              lon: 0,
              lat: 0,
              success: false,
              error: error instanceof Error ? error.message : 'Geocoding failed'
            });
          }
        }
      }
    } catch (error) {
      console.error(`Batch geocoding failed for batch ${i / BATCH_GEOCODING_CONFIG.MAX_BATCH_SIZE + 1}:`, error);

      for (const query of batch) {
        try {
          const result = await geocodeIfNeeded(env, query, request, metrics, circuitBreaker);
          results.push({ lon: result.lon, lat: result.lat, success: true, normalizedAddress: result.normalizedAddress });
        } catch (individualError) {
          results.push({
            lon: 0,
            lat: 0,
            success: false,
            error: individualError instanceof Error ? individualError.message : 'Geocoding failed'
          });
        }
      }
    }
  }

  return results;
}
